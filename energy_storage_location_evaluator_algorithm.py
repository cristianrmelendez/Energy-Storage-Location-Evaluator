# -*- coding: utf-8 -*-

"""
/***************************************************************************
 EnergyStorageLocationEvaluator
                                 A QGIS plugin
 A tool to evaluate potential locations for energy storage facilities, providing options for static and mobile configurations based on various spatial criteria.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-04-01
        copyright            : (C) 2024 by Cristian Melendez
        email                : cristian.melendez@upr.edu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Cristian Melendez'
__date__ = '2024-04-01'
__copyright__ = '(C) 2024 by Cristian Melendez'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import (QCoreApplication, QVariant)

from qgis.core import (QgsProcessing,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterMultipleLayers,
                       QgsProcessingParameterString,
                       QgsProcessingParameterEnum,
                       QgsFeatureRequest,
                       QgsFeature,
                       QgsFields,
                       QgsField,
                       QgsWkbTypes,
                       QgsFeatureSink,
                       QgsProcessingException,
                       QgsPointXY,
                       QgsProject,
                       QgsCoordinateTransform,
                       QgsCoordinateReferenceSystem,
                       QgsGeometry,
                       QgsRectangle
                       )

from .candidate import Candidate
from .road_network_analyzer import RoadNetworkAnalyzer


class EnergyStorageLocationEvaluatorAlgorithm(QgsProcessingAlgorithm):

    # Inputs
    EVALUATION_TYPE = 'EVALUATION_TYPE'
    DISTANCE_METHOD = 'DISTANCE_METHOD'
    CANDIDATES_LAYER = 'CANDIDATES_LAYER'
    BUFFER_DISTANCE = 'BUFFER_DISTANCE'
    CRITICAL_INFRASTRUCTURES = 'CRITICAL_INFRASTRUCTURES'
    INFRASTRUCTURE_WEIGHTS = 'INFRASTRUCTURE_WEIGHTS'
    CENSUS_DATA_LAYER = 'CENSUS_DATA_LAYER'
    CENSUS_DATA_WEIGHTS = 'CENSUS_DATA_WEIGHTS'
    CRITICAL_ZONES = 'CRITICAL_ZONES'
    CRITICAL_ZONE_SCORES = 'CRITICAL_ZONE_SCORES'

    # Outputs
    OUTPUT = 'OUTPUT'

    def initAlgorithm(self, config=None):

        self.addParameter(
            QgsProcessingParameterEnum(
                self.EVALUATION_TYPE,
                self.tr('Select Evaluation Type'),
                options=['Static Energy Storage', 'Mobile Energy Storage'],
                defaultValue=0  # Default to Static Energy Storage
            )
        )

        self.addParameter(
            QgsProcessingParameterEnum(
                self.DISTANCE_METHOD,
                self.tr('Select distance calculation method '
                        '(Only for static case, for mobile the only option is time travel through the road network'),
                options=['Road distance', 'Haversine distance (straight-line)', ],
                defaultValue=0  # Default to Road distance
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.CANDIDATES_LAYER,
                self.tr('Candidates Layer'),
                [QgsProcessing.TypeVectorPoint]
            )
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                self.BUFFER_DISTANCE,
                self.tr('Buffer distance (in kilometers)'),
                QgsProcessingParameterNumber.Double,
                defaultValue=1.0,
                minValue=0.0
            )
        )

        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                self.CRITICAL_INFRASTRUCTURES,
                self.tr('Critical Infrastructure Layers'),
                QgsProcessing.TypeVectorPoint
            )
        )

        # Add the parameter for critical infrastructure weights with the correct name
        self.addParameter(
            QgsProcessingParameterString(
                self.INFRASTRUCTURE_WEIGHTS,
                self.tr('Enter the weights for each infrastructure layer (comma-separated)'
                        ' in the same order as the layers. Must sum to 1.0.'),
                defaultValue='0.25,0.25,0.25,0.25'  # Example default value for 4 layers
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.CENSUS_DATA_LAYER,
                self.tr('Input here you Census Data Layer'),
                [QgsProcessing.TypeVectorPolygon]  # Accept only polygon layers
            )
        )

        self.addParameter(
            QgsProcessingParameterString(
                self.CENSUS_DATA_WEIGHTS,
                self.tr('Enter weights for the census data variables (comma-separated)'),
                defaultValue='0.25,0.25,0.25,0.25'  # Example default value for 4 layers
            )
        )

        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                self.CRITICAL_ZONES,
                self.tr('Critical Zones Layers'),
                QgsProcessing.TypeVectorPolygon  # Only polygon layers
            )
        )

        self.addParameter(
            QgsProcessingParameterString(
                self.CRITICAL_ZONE_SCORES,
                self.tr('Enter the scores for each critical zone layer (comma-separated)'
                        ' in the same order as the layers. Use negative values to subtract score.'),
                defaultValue='10,-5,-10'  # Example default value
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,  # This is the key line to define the OUTPUT parameter
                self.tr('Output layer')
            )
        )

    def safe_field_name(self, layer_name):
        # Replace spaces with underscores and remove special characters
        return ''.join([c if c.isalnum() or c == '_' else '' for c in layer_name.replace(' ', '_')])

    def processAlgorithm(self, parameters, context, feedback):
        """
        Process the algorithm and evaluate energy storage locations.
        """
        # Store feedback object for use in other methods
        self.feedback = feedback
        
        feedback.pushInfo("Starting processAlgorithm")
        
        # Initialize buffer_fields for output layer
        buffer_fields = QgsFields()
        buffer_fields.append(QgsField('id', QVariant.Int))
        buffer_fields.append(QgsField('name', QVariant.String))
        
        # Get input parameters
        candidate_layer = self.parameterAsSource(parameters, self.CANDIDATES_LAYER, context)
        buffer_distance_km = self.parameterAsDouble(parameters, self.BUFFER_DISTANCE, context)
        energy_storage_type = self.parameterAsEnum(parameters, self.EVALUATION_TYPE, context)
        distance_method = self.parameterAsEnum(parameters, self.DISTANCE_METHOD, context)
        
        # Get infrastructure layers and add their fields
        infra_layers = self.parameterAsLayerList(parameters, self.CRITICAL_INFRASTRUCTURES, context)
        for layer in infra_layers:
            infra_name = self.safe_field_name(layer.name())
            buffer_fields.append(QgsField(f'{infra_name}_Count', QVariant.Int))
            buffer_fields.append(QgsField(f'{infra_name}_Raw_Score', QVariant.Double))  # Add raw score field
            buffer_fields.append(QgsField(f'{infra_name}_Normalized_Score', QVariant.Double))
        
        # Add total infrastructure score field
        buffer_fields.append(QgsField('Total_Infrastructure_Score', QVariant.Double))
        
        # Get census layer and add census fields
        census_layer = self.parameterAsSource(parameters, self.CENSUS_DATA_LAYER, context)
        
        # Get the census weights string from parameters - moved here to fix the error
        census_weights_str = self.parameterAsString(parameters, self.CENSUS_DATA_WEIGHTS, context)
        
        census_fields = census_layer.fields()
        census_variables = []
        for i in range(6, len(census_fields)):
            field_name = census_fields.at(i).name()
            census_variables.append(field_name)
            buffer_fields.append(QgsField(f'{field_name}_Value', QVariant.Double))
            buffer_fields.append(QgsField(f'{field_name}_Score', QVariant.Double))
            
        feedback.pushInfo(f"Detected census variables: {', '.join(census_variables)}")
            
        # Validate and parse census weights
        try:
            census_weights = [float(w) for w in census_weights_str.split(',')]
        except ValueError:
            raise QgsProcessingException("Census weights must be numeric values separated by commas.")
            
        if len(census_weights) != len(census_variables):
            raise QgsProcessingException(
                f"The number of census weights ({len(census_weights)}) does not match the number of census variables ({len(census_variables)}).")
        
        if not 0.999 <= sum(census_weights) <= 1.001:
            raise QgsProcessingException(
                f"Census weights sum to {sum(census_weights)}, but they must sum to 1.0.")
        
        # Normalize census weights
        census_weight_sum = sum(census_weights)
        if census_weight_sum != 1.0:
            census_weights = [w/census_weight_sum for w in census_weights]
        
        # Get zone layers and add their score fields
        zone_layers = self.parameterAsLayerList(parameters, self.CRITICAL_ZONES, context)
        for layer in zone_layers:
            zone_name = self.safe_field_name(layer.name())
            buffer_fields.append(QgsField(f'{zone_name}_Score', QVariant.Double))
        
        # Add total zones score field
        buffer_fields.append(QgsField('Total_Zones_Score', QVariant.Double))
        
        # Add final score field
        buffer_fields.append(QgsField('Final_Score', QVariant.Double))
        
        # Convert buffer distance from km to meters for internal calculations
        buffer_distance = buffer_distance_km * 1000  # Convert km to meters

        # Log coordinate reference system info for debugging
        feedback.pushInfo(f"Candidate layer CRS: {candidate_layer.sourceCrs().authid()}")

        # Critical infrastructure layers and their weights
        infra_layers = self.parameterAsLayerList(parameters, self.CRITICAL_INFRASTRUCTURES, context)
        infra_weights_str = self.parameterAsString(parameters, self.INFRASTRUCTURE_WEIGHTS, context)
        
        # Log each infrastructure layer CRS 
        for i, layer in enumerate(infra_layers):
            feedback.pushInfo(f"Infrastructure layer {i+1} ({layer.name()}) CRS: {layer.crs().authid()}")
        
        # Census data parameters
        census_layer = self.parameterAsSource(parameters, self.CENSUS_DATA_LAYER, context)
        census_weights_str = self.parameterAsString(parameters, self.CENSUS_DATA_WEIGHTS, context)
        
        # Critical zones and their scores
        zone_layers = self.parameterAsLayerList(parameters, self.CRITICAL_ZONES, context) 
        zone_scores_str = self.parameterAsString(parameters, self.CRITICAL_ZONE_SCORES, context)
        
        # Get the census weights string from parameters - this line was missing and causing the error
        census_weights_str = self.parameterAsString(parameters, self.CENSUS_DATA_WEIGHTS, context)
        
        # Validate and parse infrastructure weights
        try:
            infra_weights = [float(w) for w in infra_weights_str.split(',')]
        except ValueError:
            raise QgsProcessingException("Infrastructure weights must be numeric values separated by commas.")
        
        if len(infra_weights) != len(infra_layers):
            raise QgsProcessingException(
                f"The number of weights ({len(infra_weights)}) does not match the number of critical infrastructure layers ({len(infra_layers)}).")
        
        # Check if weights sum to 1.0 (allowing small floating point error)
        if not 0.999 <= sum(infra_weights) <= 1.001:
            raise QgsProcessingException(
                f"Infrastructure weights sum to {sum(infra_weights)}, but they must sum to 1.0.")
            
        # Normalize weights in case of small floating point error
        weight_sum = sum(infra_weights)
        if weight_sum != 1.0:
            infra_weights = [w/weight_sum for w in infra_weights]
        
        # Extract census variables from the census layer
        census_fields = census_layer.fields()
        # According to documentation, census variables start after the 6th field (geoid)
        census_variables = []
        for i in range(6, len(census_fields)):
            field_name = census_fields.at(i).name()
            census_variables.append(field_name)
            
        feedback.pushInfo(f"Detected census variables: {', '.join(census_variables)}")
            
        # Validate and parse census weights
        try:
            census_weights = [float(w) for w in census_weights_str.split(',')]
        except ValueError:
            raise QgsProcessingException("Census weights must be numeric values separated by commas.")
            
        if len(census_weights) != len(census_variables):
            raise QgsProcessingException(
                f"The number of census weights ({len(census_weights)}) does not match the number of census variables ({len(census_variables)}).")
        
        if not 0.999 <= sum(census_weights) <= 1.001:
            raise QgsProcessingException(
                f"Census weights sum to {sum(census_weights)}, but they must sum to 1.0.")
        
        # Normalize census weights
        census_weight_sum = sum(census_weights)
        if census_weight_sum != 1.0:
            census_weights = [w/census_weight_sum for w in census_weights]
            
        # Validate and parse critical zone scores
        try:
            zone_scores = [float(s) for s in zone_scores_str.split(',')]
        except ValueError:
            raise QgsProcessingException("Critical zone scores must be numeric values separated by commas.")
            
        if len(zone_scores) != len(zone_layers):
            raise QgsProcessingException(
                f"The number of zone scores ({len(zone_scores)}) does not match the number of critical zone layers ({len(zone_layers)}).")

        feedback.pushInfo(f"Energy Storage Type: {energy_storage_type}, Distance Method: {distance_method}")
        feedback.pushInfo(f"Buffer Distance: {buffer_distance_km} km ({buffer_distance} meters)")
        
        # Initialize road network analyzer for distance calculations
        road_analyzer = RoadNetworkAnalyzer()
        
        # Test OSRM connectivity
        try:
            feedback.pushInfo("Testing OSRM connectivity...")
            # Test coordinates near San Juan, PR
            test_result = road_analyzer.get_route_info(-66.1057, 18.4655, -66.0949, 18.4596)
            feedback.pushInfo(f"OSRM test successful, distance: {test_result['distance']:.2f} meters, duration: {test_result['duration']:.2f} seconds")
        except Exception as e:
            feedback.reportError(f"OSRM test failed: {str(e)}. Road distance calculations will fall back to Haversine.")
            feedback.pushInfo("Make sure OSRM server is running on http://127.0.0.1:5001")
        
        # Create candidate objects from features
        candidates = []
        total_candidates = candidate_layer.featureCount()
        feedback.pushInfo(f"Processing {total_candidates} candidate sites...")
        
        for i, feature in enumerate(candidate_layer.getFeatures()):
            if feedback.isCanceled():
                break
                
            # Pass feedback to candidate for better logging
            candidate = Candidate(feature, buffer_distance, feedback)
            candidates.append(candidate)
            
            # Update progress
            feedback.setProgress(int((i / total_candidates) * 10))  # Use first 10% for candidate creation
        
        # 1. EVALUATE CRITICAL ZONES FIRST
        feedback.pushInfo("Step 1: Evaluating candidates against critical zones...")
        
        # Clear existing zone scores to ensure fresh calculation
        for candidate in candidates:
            candidate.critical_zones.clear()
            
        for i, zone_layer in enumerate(zone_layers):
            zone_name = self.safe_field_name(zone_layer.name())
            zone_score = zone_scores[i]
            
            feedback.pushInfo(f"Processing critical zone: {zone_name} with score {zone_score}")
            feedback.pushInfo(f"Zone layer CRS: {zone_layer.crs().authid()}")
            
            for j, candidate in enumerate(candidates):
                if feedback.isCanceled():
                    break
                    
                # Check if candidate intersects with zone
                intersects = False
                for zone_feature in zone_layer.getFeatures():
                    if zone_feature.geometry().intersects(candidate.feature.geometry()):
                        intersects = True
                        break
                        
                if intersects:
                    # Apply zone score - could be positive or negative
                    candidate.set_critical_zone_score(zone_name, zone_score)
                    feedback.pushInfo(f"Candidate {j+1} intersects with {zone_name}, score: {zone_score}")
                else:
                    # No intersection, no score impact (explicitly set to 0 to ensure all fields exist)
                    candidate.set_critical_zone_score(zone_name, 0)
            
            # Update progress
            feedback.setProgress(10 + int((i / len(zone_layers)) * 20))  # Use 10-30% for zones
        
        feedback.pushInfo(f"Critical zone evaluation completed for all {len(candidates)} candidates")
        
        # 2. PROCESS INFRASTRUCTURE FOR EACH CANDIDATE
        feedback.pushInfo("Step 2: Evaluating candidates against critical infrastructure...")
        
        # Dictionary to store min/max scores for each infrastructure type for normalization
        infra_score_ranges = {}
        
        for i, infra_layer in enumerate(infra_layers):
            infra_name = self.safe_field_name(infra_layer.name())
            weight = infra_weights[i]
            
            feedback.pushInfo(f"Processing infrastructure: {infra_name} with weight {weight}")
            feedback.pushInfo(f"Layer has {infra_layer.featureCount()} total features")
            
            # Check if there's any data in this layer
            if infra_layer.featureCount() == 0:
                feedback.reportError(f"WARNING: Layer {infra_name} has no features!")
                continue
                
            # Sample the first feature to verify data is as expected
            sample_feat = next(infra_layer.getFeatures())
            if sample_feat:
                feedback.pushInfo(f"Sample feature geometry type: {sample_feat.geometry().wkbType()}")
                if sample_feat.geometry().isGeosValid():
                    pt = sample_feat.geometry().asPoint()
                    feedback.pushInfo(f"Sample point coordinates: ({pt.x():.6f}, {pt.y():.6f})")
                else:
                    feedback.reportError(f"Sample feature has invalid geometry in layer {infra_name}")
            
            # Initialize min and max scores for this infrastructure type
            infra_score_ranges[infra_name] = {'min': float('inf'), 'max': float('-inf')}
            
            for j, candidate in enumerate(candidates):
                if feedback.isCanceled():
                    break
                    
                # Display candidate info for debugging
                candidate_id = candidate.feature['id'] if 'id' in candidate.feature.fields().names() else j
                feedback.pushInfo(f"Processing candidate {candidate_id}")
                
                # Score for this infrastructure type for this candidate
                total_infra_score = 0
                infra_count = 0
                
                # Debug info about the buffer
                feedback.pushInfo(f"Buffer area: {candidate.buffer.area():.2f} sq meters")
                    
                # Get infrastructure features within buffer using spatial filtering first
                intersecting_features = self.get_intersecting_features(candidate.buffer, infra_layer)
                feedback.pushInfo(f"Found {len(intersecting_features)} {infra_name} features intersecting with candidate {j+1}")
                
                # Score each infrastructure feature based on distance, but only for those within the buffer
                for infra_feature in intersecting_features:
                    # Calculate distance based on selected method and storage type
                    start_point = candidate.feature.geometry().asPoint()
                    end_point = infra_feature.geometry().asPoint()
                    
                    if energy_storage_type == 0:  # Static
                        if distance_method == 0:  # Road distance
                            try:
                                distance = road_analyzer.calculate_road_distance(start_point.x(), start_point.y(),
                                                                          end_point.x(), end_point.y())
                                feedback.pushInfo(f"Road Distance to {infra_name}: {distance:.2f} meters")
                            except Exception as e:
                                feedback.reportError(f"Road distance calculation failed: {str(e)}, falling back to Haversine")
                                distance = candidate.feature.geometry().distance(infra_feature.geometry())
                                feedback.pushInfo(f"Fallback Haversine Distance to {infra_name}: {distance:.2f} meters")
                        else:  # Haversine
                            distance = candidate.feature.geometry().distance(infra_feature.geometry())
                            feedback.pushInfo(f"Haversine Distance to {infra_name}: {distance:.2f} meters")
                    else:  # Mobile, using ETA
                        try:
                            distance = road_analyzer.calculate_eta(start_point.x(), start_point.y(), 
                                                                end_point.x(), end_point.y())
                            feedback.pushInfo(f"ETA to {infra_name}: {distance:.2f} seconds")
                        except Exception as e:
                            feedback.reportError(f"ETA calculation failed: {str(e)}, falling back to Haversine")
                            distance = candidate.feature.geometry().distance(infra_feature.geometry())
                            feedback.pushInfo(f"Fallback Haversine Distance to {infra_name}: {distance:.2f} meters")
                    
                    # Since we've already filtered for features within the buffer, we can directly apply the score
                    feature_score = max(0, (buffer_distance - distance))  # Raw score without weight
                    weighted_score = feature_score * weight  # Apply weight for normalized score
                    feedback.pushInfo(f"Raw score for feature: {feature_score:.2f}, Weighted score: {weighted_score:.2f}")
                    total_infra_score += weighted_score
                    infra_count += 1  # Increment count for each feature within the buffer
                
                # Store infrastructure count, raw score, and weighted score for this type
                candidate.infrastructures[infra_name] = {
                    'count': infra_count, 
                    'raw_score': total_infra_score / weight if weight > 0 else 0,  # Remove weight to get raw score
                    'score': total_infra_score  # This will be normalized later
                }
            
            # Update progress
            feedback.setProgress(30 + int((i / len(infra_layers)) * 20))  # Use 30-50% for infrastructure
        
        # 3. PROCESS CENSUS DATA FOR EACH CANDIDATE
        feedback.pushInfo("Step 3: Evaluating candidates against census data...")
        
        # Dictionary to store min/max values for each census variable for normalization
        census_value_ranges = {var: {'min': float('inf'), 'max': float('-inf')} for var in census_variables}
        
        # Clear existing census scores to ensure fresh calculation
        for candidate in candidates:
            candidate.census_scores = {}
            
        for j, candidate in enumerate(candidates):
            if feedback.isCanceled():
                break
            
            # Find the census area(s) that contain this candidate
            containing_census_features = []
            for census_feature in census_layer.getFeatures():
                if census_feature.geometry().contains(candidate.feature.geometry()):
                    containing_census_features.append(census_feature)
            
            feedback.pushInfo(f"Found {len(containing_census_features)} census areas containing candidate {j+1}")
            
            # Extract and store census values for this candidate
            if containing_census_features:
                # If multiple census areas contain the candidate, use the first one
                census_feature = containing_census_features[0]
                
                for v, variable in enumerate(census_variables):
                    if variable not in census_feature.fields().names():
                        feedback.reportError(f"Census variable '{variable}' not found in census layer")
                        continue
                    
                    value = census_feature[variable]
                    # Store raw value
                    candidate.census_data[variable] = value
                    
                    # Update min/max values for normalization
                    census_value_ranges[variable]['min'] = min(census_value_ranges[variable]['min'], value)
                    census_value_ranges[variable]['max'] = max(census_value_ranges[variable]['max'], value)
                    
                    feedback.pushInfo(f"Census {variable} for candidate {j+1}: {value}")
            else:
                feedback.pushInfo(f"No census areas found containing candidate {j+1}")
                for variable in census_variables:
                    candidate.census_data[variable] = 0
        
        # 4. NORMALIZE SCORES FOR INFRASTRUCTURE AND CENSUS DATA
        feedback.pushInfo("Step 4: Normalizing all scores...")
        
        # Before normalizing scores, ensure all candidates have entries for all infrastructures
        for infra_layer in infra_layers:
            infra_name = self.safe_field_name(infra_layer.name())
            for candidate in candidates:
                # Initialize the score to 0 if it doesn't exist
                if infra_name not in candidate.infrastructures:
                    candidate.update_infrastructure_count(infra_name)
                    candidate.set_infrastructure_score(infra_name, 0.0)
                    
        # Compute actual min/max scores across all candidates for each infrastructure type
        for infra_name in [self.safe_field_name(layer.name()) for layer in infra_layers]:
            scores = [c.infrastructures.get(infra_name, {}).get('score', 0.0) for c in candidates]
            if scores:
                min_score = min(scores)
                max_score = max(scores)
                infra_score_ranges[infra_name] = {'min': min_score, 'max': max_score}
                feedback.pushInfo(f"Score range for {infra_name}: {min_score} to {max_score}")
        
        # Normalize infrastructure scores
        for infra_name, score_range in infra_score_ranges.items():
            min_score = score_range['min']
            max_score = score_range['max']
            
            # If all scores are the same, prevent division by zero
            if min_score == max_score:
                # If all are zero, set normalized score to 0
                if min_score == 0.0:
                    normalized_value = 0.0
                # Otherwise, set to a positive value
                else:
                    normalized_value = 1.0 if min_score > 0 else 0.0
                    
                feedback.pushInfo(f"All {infra_name} scores identical ({min_score}), normalized to {normalized_value}")
                
                for candidate in candidates:
                    candidate.set_infrastructure_score(infra_name, normalized_value)
            else:
                # Normal case: Apply normalization formula
                for candidate in candidates:
                    raw_score = candidate.infrastructures.get(infra_name, {}).get('score', 0.0)
                    normalized_score = (raw_score - min_score) / (max_score - min_score)
                    candidate.set_infrastructure_score(infra_name, normalized_score)
        
        # Similar approach for census data
        # Ensure all candidates have entries for all census variables
        for variable in census_variables:
            for candidate in candidates:
                if variable not in candidate.census_data:
                    candidate.census_data[variable] = 0.0
                    
        # Compute actual min/max values for census variables
        for variable in census_variables:
            values = [c.census_data.get(variable, 0.0) for c in candidates]
            if values:
                min_value = min(values)
                max_value = max(values)
                census_value_ranges[variable] = {'min': min_value, 'max': max_value}
                feedback.pushInfo(f"Value range for {variable}: {min_value} to {max_value}")
        
        # Normalize and weight census data
        for v, variable in enumerate(census_variables):
            min_value = census_value_ranges[variable]['min']
            max_value = census_value_ranges[variable]['max']
            weight = census_weights[v]
            
            feedback.pushInfo(f"Processing census variable: {variable} with weight {weight}")
            
            # If all values are the same, prevent division by zero
            if min_value == max_value:
                if min_value == 0:
                    normalized_value = 0.0
                else:
                    normalized_value = 1.0 if min_value > 0 else 0.0
                
                weighted_score = normalized_value * weight
                feedback.pushInfo(f"All {variable} values identical ({min_value}), normalized to {normalized_value}, weighted to {weighted_score}")
                
                for candidate in candidates:
                    # Store the score in both locations
                    candidate.census_scores[variable] = weighted_score 
                    candidate.census_data[variable + "_score"] = weighted_score
                    feedback.pushInfo(f"Set {variable} score for candidate to {weighted_score}")
            else:
                # Normal case: Apply normalization and weighting
                for candidate in candidates:
                    value = candidate.census_data.get(variable, 0.0)
                    normalized_value = (value - min_value) / (max_value - min_value) if max_value > min_value else 0
                    weighted_score = normalized_value * weight
                    
                    # Store the score in both locations 
                    candidate.census_scores[variable] = weighted_score
                    candidate.census_data[variable + "_score"] = weighted_score
                    
                    feedback.pushInfo(f"Census {variable}: raw={value}, norm={normalized_value:.4f}, weighted={weighted_score:.4f}")

        # Create the output layer
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT, context, buffer_fields, QgsWkbTypes.Polygon,
                                               candidate_layer.sourceCrs())
                                               
        # Now calculate the final scores for each candidate
        for candidate in candidates:
            # Calculate total infrastructure score
            total_infra_score = sum(info.get('normalized_score', 0) 
                                   for info in candidate.infrastructures.values())
            
            # Calculate total census score
            total_census_score = sum(candidate.census_scores.values())
            
            # Calculate total zone score
            total_zone_score = sum(candidate.critical_zones.values())
            
            # Calculate final score
            final_score = total_infra_score + total_census_score + total_zone_score
            
            # Store these scores for use in output
            candidate.total_infra_score = total_infra_score
            candidate.total_census_score = total_census_score
            candidate.total_zone_score = total_zone_score
            candidate.final_score = final_score
            
            feedback.pushInfo(f"Candidate scores: infra={total_infra_score:.4f}, census={total_census_score:.4f}, "
                             f"zones={total_zone_score:.4f}, final={final_score:.4f}")
        
        # Populate the output layer with features
        field_count = len(buffer_fields)
        feedback.pushInfo(f"Output layer has {field_count} fields defined")
        
        for field_idx in range(field_count):
            field = buffer_fields.at(field_idx)
            feedback.pushInfo(f"Field {field_idx}: {field.name()} ({field.typeName()})")
        
        for candidate in candidates:  # Iterate over valid candidates
            if feedback.isCanceled():
                break
                
            # Create a new feature for the output layer
            out_feature = QgsFeature(buffer_fields)
            out_feature.setGeometry(candidate.buffer)  # Set the buffer geometry as the feature's geometry
            
            # Get the candidate's ID and name directly from the feature's attributes
            # If the field exists but the value is NULL, use a default value
            candidate_id = None
            candidate_name = None
            
            if 'Id' in candidate.feature.fields().names():
                field_idx = candidate.feature.fields().indexFromName('Id')
                candidate_id = candidate.feature.attributes()[field_idx]
                
            if 'Name' in candidate.feature.fields().names():
                field_idx = candidate.feature.fields().indexFromName('Name')
                candidate_name = candidate.feature.attributes()[field_idx]
            
            # Use defaults if values are still None
            if candidate_id is None:
                candidate_id = candidates.index(candidate)
            if candidate_name is None or candidate_name == '':
                candidate_name = f"Candidate {candidate_id}"
            
            # Start with an empty attributes array that we'll fill with exactly the right number of attributes
            attributes = []
            
            # ID and name (first two fields)
            attributes.append(candidate_id)  # Field 0: id
            attributes.append(candidate_name)  # Field 1: name
            
            # Calculate the total scores first so we can reference them when logging
            total_infra_score = sum(info.get('normalized_score', 0) 
                               for info in candidate.infrastructures.values())
            
            total_census_score = sum(candidate.census_scores.values())
            
            total_zone_score = sum(candidate.critical_zones.values())
            
            # Calculate final score (sum of all components)
            final_score = total_infra_score + total_census_score + total_zone_score
            
            # Log detailed information about final score calculation
            feedback.pushInfo(f"Final score components for {candidate_name}:")
            feedback.pushInfo(f"  Infrastructure: {total_infra_score}")
            feedback.pushInfo(f"  Census: {total_census_score}")
            feedback.pushInfo(f"  Zones: {total_zone_score}")
            feedback.pushInfo(f"  Total Final Score: {final_score}")
            
            # Append infrastructure data
            for infra_layer in infra_layers:
                infra_name = self.safe_field_name(infra_layer.name())
                count = candidate.infrastructures.get(infra_name, {}).get('count', 0)
                raw_score = candidate.infrastructures.get(infra_name, {}).get('raw_score', 0)
                normalized_score = candidate.infrastructures.get(infra_name, {}).get('normalized_score', 0)
                attributes.append(count)
                attributes.append(raw_score)
                attributes.append(normalized_score)
            
            # Add the total infrastructure score
            attributes.append(total_infra_score)
            
            # Add census data values and scores
            for variable in census_variables:
                value = candidate.census_data.get(variable, 0)
                score = candidate.census_scores.get(variable, 0)
                attributes.append(value)
                attributes.append(score)
            
            # Add critical zone scores
            for zone_layer in zone_layers:
                zone_name = self.safe_field_name(zone_layer.name())
                score = candidate.critical_zones.get(zone_name, 0)
                attributes.append(score)
            
            # Add the total zones score
            attributes.append(total_zone_score)
            
            # Add the final score
            attributes.append(final_score)
            
            # Verify attribute count exactly matches field count
            if len(attributes) != field_count:
                feedback.reportError(f"FIELD COUNT MISMATCH: {len(attributes)} attributes vs {field_count} fields")
                
                # List all attributes with their values for debugging
                for i, attr in enumerate(attributes):
                    field_name = buffer_fields.at(i).name() if i < field_count else f"Extra_{i-field_count+1}"
                    feedback.reportError(f"  Attribute {i}: {field_name} = {attr}")
                
                # Let's fix the count by adding or removing attributes
                if len(attributes) > field_count:
                    feedback.reportError(f"Truncating attributes from {len(attributes)} to {field_count}")
                    attributes = attributes[:field_count]
                else:
                    while len(attributes) < field_count:
                        attributes.append(None)
                        feedback.reportError(f"Added dummy attribute at position {len(attributes)-1}")
            
            # Assign the attributes to the output feature
            out_feature.setAttributes(attributes)
            
            # Add the feature to the sink
            if not sink.addFeature(out_feature, QgsFeatureSink.FastInsert):
                feedback.reportError(f"Failed to add feature for candidate {candidate_name}")
            
            # For debugging, check the first feature's attributes to make sure Final_Score is included
            if candidates.index(candidate) == 0:
                feedback.pushInfo("First feature attributes:")
                for i, attr in enumerate(out_feature.attributes()):
                    field_name = buffer_fields.at(i).name() if i < field_count else f"Extra_{i}"
                    feedback.pushInfo(f"  {i}: {field_name} = {attr}")
            
            # Update progress
            feedback.setProgress(80 + int((candidates.index(candidate) / len(candidates)) * 20))  # Use final 20% for output

        # Return the results including the output layer
        feedback.pushInfo("Processing completed successfully")
        return {self.OUTPUT: dest_id}

    def get_intersecting_features(self, buffer, layer):
        """
        Get features from layer that intersect with buffer geometry.
        
        Args:
            buffer: Buffer geometry in the candidate's CRS
            layer: Layer to get features from, potentially in a different CRS
            
        Returns:
            List of features that intersect with buffer
        """
        intersecting_features = []
        
        # Check if the buffer geometry is valid
        if not buffer.isGeosValid():
            self.feedback.reportError(f"Buffer geometry is not valid for layer: {layer.name()}")
            return intersecting_features
        
        # Debug buffer information
        self.feedback.pushInfo(f"Buffer type: {buffer.wkbType()}, area: {buffer.area():.2f} sq meters")
        
        # Get buffer CRS information
        buffer_crs = QgsProject.instance().crs()
        layer_crs = layer.crs()
        
        self.feedback.pushInfo(f"Buffer CRS: {buffer_crs.authid()}, Layer CRS: {layer_crs.authid()}")
        
        # Get the buffer centroid for debugging
        centroid = buffer.centroid().asPoint()
        self.feedback.pushInfo(f"Buffer centroid: ({centroid.x():.6f}, {centroid.y():.6f})")
        
        # Calculate approximate buffer radius from area (for debugging)
        buffer_radius = (buffer.area() / 3.14159) ** 0.5
        self.feedback.pushInfo(f"Calculated buffer radius: {buffer_radius:.2f} meters")
        
        # Create a copy of the buffer geometry for transformation
        buffer_geom = QgsGeometry(buffer)
        
        # Transform buffer to layer CRS if needed
        if buffer_crs.authid() != layer_crs.authid():
            self.feedback.pushInfo(f"Transforming buffer from {buffer_crs.authid()} to {layer_crs.authid()}")
            try:
                transform = QgsCoordinateTransform(buffer_crs, layer_crs, QgsProject.instance())
                buffer_geom.transform(transform)
                
                # Debug the transformed buffer
                transformed_centroid = buffer_geom.centroid().asPoint()
                self.feedback.pushInfo(f"Transformed buffer centroid: ({transformed_centroid.x():.6f}, {transformed_centroid.y():.6f})")
                self.feedback.pushInfo(f"Transformed buffer area: {buffer_geom.area():.2f} sq meters")
            except Exception as e:
                self.feedback.reportError(f"Error transforming buffer: {str(e)}")
                # In case of transformation error, return empty result
                return intersecting_features
        
        # Get the correct bounding box from the buffer geometry
        bbox = buffer_geom.boundingBox()
        
        # Debug the bounding box (should be in the layer's CRS)
        self.feedback.pushInfo(f"Bounding box min: ({bbox.xMinimum():.6f}, {bbox.yMinimum():.6f})")
        self.feedback.pushInfo(f"Bounding box max: ({bbox.xMaximum():.6f}, {bbox.yMaximum():.6f})")
        self.feedback.pushInfo(f"Bounding box width: {bbox.width():.6f}, height: {bbox.height():.6f}")
        
        # ALWAYS create a manual bounding box for more reliable results
        # This fixes the issue with invalid bounding boxes
        center = buffer_geom.centroid().asPoint()
        
        # Set appropriate delta based on the CRS
        if layer_crs.authid().startswith("EPSG:4326"):
            # For EPSG:4326 (WGS 84), use degrees (about 2km at equator)
            delta = 0.02
        else:
            # For projected CRSs, use meters/feet based on buffer radius
            delta = buffer_radius * 1.1  # 10% larger than buffer radius
        
        # Create a manual bounding box
        manual_bbox = QgsRectangle(
            center.x() - delta,
            center.y() - delta,
            center.x() + delta,
            center.y() + delta
        )
        
        self.feedback.pushInfo(f"Created manual bbox: ({manual_bbox.xMinimum():.6f}, {manual_bbox.yMinimum():.6f}) - ({manual_bbox.xMaximum():.6f}, {manual_bbox.yMaximum():.6f})")
        bbox = manual_bbox
        
        # Use the corrected bounding box for spatial filtering
        request = QgsFeatureRequest().setFilterRect(bbox)
        
        # Count features in layer and in bounding box
        total_features = layer.featureCount()
        feature_count_in_bbox = 0
        contained_features = 0
        
        # Process features within the bounding box and check actual containment
        for feature in layer.getFeatures(request):
            feature_count_in_bbox += 1
            geom = feature.geometry()
            
            if not geom or not geom.isGeosValid():
                self.feedback.pushInfo(f"Skipping invalid geometry in layer {layer.name()}")
                continue
                
            # Check if the feature is truly inside or intersects the buffer
            # For point features, check containment
            if buffer_geom.contains(geom):
                contained_features += 1
                intersecting_features.append(feature)
                
                # Log only a limited number of points to avoid overwhelming logs
                if contained_features <= 5:
                    if geom.type() == QgsWkbTypes.PointGeometry:
                        point = geom.asPoint()
                        self.feedback.pushInfo(f"Found point inside buffer at {point.x():.6f}, {point.y():.6f}")
            elif buffer_geom.intersects(geom):
                # For non-point features that intersect but aren't contained
                intersecting_features.append(feature)
                contained_features += 1
                if contained_features <= 5:
                    self.feedback.pushInfo("Found intersecting feature (not contained)")
        
        # Report statistics
        self.feedback.pushInfo(f"Layer {layer.name()} has {total_features} total features")
        self.feedback.pushInfo(f"Features in bounding box: {feature_count_in_bbox}")
        self.feedback.pushInfo(f"Features actually contained or intersecting buffer: {contained_features}")
        
        # Add containment ratio statistics if applicable
        if feature_count_in_bbox > 0:
            containment_ratio = contained_features / feature_count_in_bbox
            self.feedback.pushInfo(f"Containment ratio: {containment_ratio:.2%}")
            
        return intersecting_features

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'EvaluateEnergyStorageSites'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Energy Storage Evaluation'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return EnergyStorageLocationEvaluatorAlgorithm()
