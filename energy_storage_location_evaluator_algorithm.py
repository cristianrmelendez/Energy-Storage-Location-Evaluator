# -*- coding: utf-8 -*-

"""
/***************************************************************************
 EnergyStorageLocationEvaluator
                                 A QGIS plugin
 A tool to evaluate potential locations for energy storage facilities, providing options for static and mobile configurations based on various spatial criteria.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-01-01
        copyright            : (C) 2025 by Cristian Melendez
        email                : cristian.melendez@upr.edu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Cristian Melendez'
__date__ = '2025-01-01'
__copyright__ = '(C) 2025 by Cristian Melendez'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import (QCoreApplication, QVariant)

from qgis.core import (QgsProcessing,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterMultipleLayers,
                       QgsProcessingParameterString,
                       QgsProcessingParameterEnum,
                       QgsFeatureRequest,
                       QgsFeature,
                       QgsFields,
                       QgsField,
                       QgsWkbTypes,
                       QgsFeatureSink,
                       QgsProcessingException,
                       QgsPointXY,
                       QgsProject,
                       QgsCoordinateTransform,
                       QgsCoordinateReferenceSystem,
                       QgsGeometry,
                       QgsRectangle
                       )

from .candidate import Candidate
from .static_model import StaticEnergyStorageEvaluator


class EnergyStorageLocationEvaluatorAlgorithm(QgsProcessingAlgorithm):

    # Inputs
    EVALUATION_TYPE = 'EVALUATION_TYPE'
    DISTANCE_METHOD = 'DISTANCE_METHOD'
    CANDIDATES_LAYER = 'CANDIDATES_LAYER'
    BUFFER_DISTANCE = 'BUFFER_DISTANCE'
    CRITICAL_INFRASTRUCTURES = 'CRITICAL_INFRASTRUCTURES'
    INFRASTRUCTURE_WEIGHTS = 'INFRASTRUCTURE_WEIGHTS'
    CENSUS_DATA_LAYER = 'CENSUS_DATA_LAYER'
    CENSUS_DATA_WEIGHTS = 'CENSUS_DATA_WEIGHTS'
    CRITICAL_ZONES = 'CRITICAL_ZONES'
    CRITICAL_ZONE_SCORES = 'CRITICAL_ZONE_SCORES'

    # Outputs
    OUTPUT = 'OUTPUT'

    def initAlgorithm(self, config=None):

        self.addParameter(
            QgsProcessingParameterEnum(
                self.EVALUATION_TYPE,
                self.tr('Select Evaluation Type'),
                options=['Static Energy Storage', 'Mobile Energy Storage'],
                defaultValue=0  # Default to Static Energy Storage
            )
        )

        self.addParameter(
            QgsProcessingParameterEnum(
                self.DISTANCE_METHOD,
                self.tr('Select distance calculation method '
                        '(Only for static case, for mobile the only option is time travel through the road network'),
                options=['Road distance', 'Haversine distance (straight-line)', ],
                defaultValue=0  # Default to Road distance
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.CANDIDATES_LAYER,
                self.tr('Candidates Layer'),
                [QgsProcessing.TypeVectorPoint]
            )
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                self.BUFFER_DISTANCE,
                self.tr('Buffer distance (in kilometers)'),
                QgsProcessingParameterNumber.Double,
                defaultValue=1.0,
                minValue=0.0
            )
        )

        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                self.CRITICAL_INFRASTRUCTURES,
                self.tr('Critical Infrastructure Layers'),
                QgsProcessing.TypeVectorPoint
            )
        )

        # Add the parameter for critical infrastructure weights with the correct name
        self.addParameter(
            QgsProcessingParameterString(
                self.INFRASTRUCTURE_WEIGHTS,
                self.tr('Enter the weights for each infrastructure layer (comma-separated)'
                        ' in the same order as the layers. Must sum to 1.0.'),
                defaultValue='0.25,0.25,0.25,0.25'  # Example default value for 4 layers
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.CENSUS_DATA_LAYER,
                self.tr('Input here you Census Data Layer'),
                [QgsProcessing.TypeVectorPolygon]  # Accept only polygon layers
            )
        )

        self.addParameter(
            QgsProcessingParameterString(
                self.CENSUS_DATA_WEIGHTS,
                self.tr('Enter weights for the census data variables (comma-separated)'),
                defaultValue='0.25,0.25,0.25,0.25'  # Example default value for 4 layers
            )
        )

        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                self.CRITICAL_ZONES,
                self.tr('Critical Zones Layers'),
                QgsProcessing.TypeVectorPolygon  # Only polygon layers
            )
        )

        self.addParameter(
            QgsProcessingParameterString(
                self.CRITICAL_ZONE_SCORES,
                self.tr('Enter the scores for each critical zone layer (comma-separated)'
                        ' in the same order as the layers. Use negative values to subtract score.'),
                defaultValue='10,-5,-10'  # Example default value
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,  # This is the key line to define the OUTPUT parameter
                self.tr('Output layer')
            )
        )

    def safe_field_name(self, layer_name):
        # Replace spaces with underscores and remove special characters
        return ''.join([c if c.isalnum() or c == '_' else '' for c in layer_name.replace(' ', '_')])

    def _initialize_output_fields(self):
        """Initialize the output layer fields structure."""
        buffer_fields = QgsFields()
        buffer_fields.append(QgsField('id', QVariant.Int))
        buffer_fields.append(QgsField('name', QVariant.String))
        return buffer_fields

    def _validate_weights(self, weights_str, expected_count, weight_type):
        """Validate and normalize weights.
        
        Args:
            weights_str (str): Comma-separated weights
            expected_count (int): Expected number of weights
            weight_type (str): Type of weights for error messages
            
        Returns:
            list: Normalized weights
        """
        try:
            weights = [float(w) for w in weights_str.split(',')]
        except ValueError:
            raise QgsProcessingException(f"{weight_type} weights must be numeric values separated by commas.")
        
        if len(weights) != expected_count:
            raise QgsProcessingException(
                f"The number of {weight_type.lower()} weights ({len(weights)}) does not match "
                f"the expected count ({expected_count}).")
        
        if not 0.999 <= sum(weights) <= 1.001:
            raise QgsProcessingException(
                f"{weight_type} weights sum to {sum(weights)}, but they must sum to 1.0.")
        
        # Normalize weights to exactly 1.0
        weight_sum = sum(weights)
        if weight_sum != 1.0:
            weights = [w/weight_sum for w in weights]
            
        return weights

    def _add_infrastructure_fields(self, buffer_fields, infra_layers):
        """Add infrastructure-related fields to the output structure."""
        for layer in infra_layers:
            infra_name = self.safe_field_name(layer.name())
            buffer_fields.append(QgsField(f'{infra_name}_Count', QVariant.Int))
            buffer_fields.append(QgsField(f'{infra_name}_Raw_Score', QVariant.Double))
            buffer_fields.append(QgsField(f'{infra_name}_Normalized_Score', QVariant.Double))
            # Add field for outage costs per infrastructure type
            buffer_fields.append(QgsField(f'{infra_name}_Outage_Cost_Savings', QVariant.Double))
        buffer_fields.append(QgsField('Total_Infrastructure_Score', QVariant.Double))
        # Add field for total outage cost savings
        buffer_fields.append(QgsField('Total_Outage_Cost_Savings', QVariant.Double))
        return buffer_fields

    def _add_census_fields(self, buffer_fields, census_layer):
        """Add census-related fields and extract census variables."""
        census_fields = census_layer.fields()
        census_variables = []
        
        for i in range(6, len(census_fields)):
            field_name = census_fields.at(i).name()
            census_variables.append(field_name)
            buffer_fields.append(QgsField(f'{field_name}_Value', QVariant.Double))
            buffer_fields.append(QgsField(f'{field_name}_Score', QVariant.Double))
            
        return buffer_fields, census_variables

    def _add_zone_fields(self, buffer_fields, zone_layers):
        """Add zone-related fields to the output structure."""
        for layer in zone_layers:
            zone_name = self.safe_field_name(layer.name())
            buffer_fields.append(QgsField(f'{zone_name}_Score', QVariant.Double))
        
        buffer_fields.append(QgsField('Total_Zones_Score', QVariant.Double))
        buffer_fields.append(QgsField('Final_Score', QVariant.Double))
        return buffer_fields

    def _log_crs_info(self, candidate_layer, infra_layers, feedback):
        """Log CRS information for debugging."""
        feedback.pushInfo(f"Candidate layer CRS: {candidate_layer.sourceCrs().authid()}")
        for i, layer in enumerate(infra_layers):
            feedback.pushInfo(f"Infrastructure layer {i+1} ({layer.name()}) CRS: {layer.crs().authid()}")

    def processAlgorithm(self, parameters, context, feedback):
        """Process the algorithm."""
        feedback.pushInfo("Starting processAlgorithm")

        # Initialize the static evaluator
        evaluator = StaticEnergyStorageEvaluator(feedback)

        # Part 1: Get input parameters
        candidate_layer = self.parameterAsSource(parameters, self.CANDIDATES_LAYER, context)
        buffer_distance_km = self.parameterAsDouble(parameters, self.BUFFER_DISTANCE, context)
        energy_storage_type = self.parameterAsEnum(parameters, self.EVALUATION_TYPE, context)
        distance_method = self.parameterAsEnum(parameters, self.DISTANCE_METHOD, context)
        
        # Get layers and their corresponding weights/scores
        infra_layers = self.parameterAsLayerList(parameters, self.CRITICAL_INFRASTRUCTURES, context)
        infra_weights_str = self.parameterAsString(parameters, self.INFRASTRUCTURE_WEIGHTS, context)
        
        census_layer = self.parameterAsSource(parameters, self.CENSUS_DATA_LAYER, context)
        census_weights_str = self.parameterAsString(parameters, self.CENSUS_DATA_WEIGHTS, context)
        
        zone_layers = self.parameterAsLayerList(parameters, self.CRITICAL_ZONES, context)
        zone_scores_str = self.parameterAsString(parameters, self.CRITICAL_ZONE_SCORES, context)

        # Part 2: Initialize output structure
        buffer_fields = self._initialize_output_fields()
        buffer_fields = self._add_infrastructure_fields(buffer_fields, infra_layers)
        buffer_fields, census_variables = self._add_census_fields(buffer_fields, census_layer)
        buffer_fields = self._add_zone_fields(buffer_fields, zone_layers)

        # Part 3: Validate weights using the evaluator
        infra_weights, census_weights = evaluator.validate_weights(
            infra_weights_str, census_weights_str,
            len(infra_layers), len(census_variables)
        )

        # Parse zone scores
        try:
            zone_scores = [float(s) for s in zone_scores_str.split(',')]
            if len(zone_scores) != len(zone_layers):
                raise QgsProcessingException(
                    f"Number of zone scores ({len(zone_scores)}) does not match "
                    f"number of zone layers ({len(zone_layers)})"
                )
        except ValueError:
            raise QgsProcessingException("Zone scores must be numeric values")

        # Convert buffer distance to meters
        buffer_distance = buffer_distance_km * 1000

        # Create candidates
        candidates = []
        total = candidate_layer.featureCount()
        for current, feature in enumerate(candidate_layer.getFeatures()):
            if feedback.isCanceled():
                break
            candidate = Candidate(feature, buffer_distance, feedback)
            candidates.append(candidate)
            feedback.setProgress(int(current * 100 / total))

        # Process critical zones
        evaluator.evaluate_critical_zones(candidates, zone_layers, zone_scores)

        # Process infrastructure
        for candidate in candidates:
            if feedback.isCanceled():
                break
            evaluator.evaluate_infrastructure(
                candidate, infra_layers, infra_weights,
                buffer_distance, distance_method
            )

        # Process census data
        for candidate in candidates:
            if feedback.isCanceled():
                break
            for census_feature in census_layer.getFeatures():
                if census_feature.geometry().contains(candidate.feature.geometry()):
                    for var in census_variables:
                        value = census_feature[var]
                        candidate.set_census_data(var, value)
                    break

        # Normalize and weight scores
        evaluator.normalize_and_weight_scores(
            candidates, infra_layers, census_variables,
            infra_weights, census_weights
        )

        # Calculate final scores
        evaluator.calculate_final_scores(candidates)

        # Create output layer
        (sink, dest_id) = self.parameterAsSink(
            parameters, self.OUTPUT, context,
            buffer_fields, QgsWkbTypes.Polygon, candidate_layer.sourceCrs()
        )

        feedback.pushInfo(f"Created output sink with {len(buffer_fields)} fields")
        
        # Write results to output layer
        for candidate in candidates:
            if feedback.isCanceled():
                break

            # Debug buffer geometry
            if not candidate.buffer.isGeosValid():
                feedback.pushWarning(f"Invalid buffer geometry for candidate {candidate.id}")
                continue
                
            feedback.pushInfo(f"Processing candidate {candidate.id} with buffer area: {candidate.buffer.area()}")

            feature = QgsFeature(buffer_fields)
            feature.setGeometry(candidate.buffer)

            # Get proper ID for the feature, first try to use the Id field if present
            # Otherwise fall back to the feature's internal ID
            feature_id = candidate.id  # Default to candidate's internal ID
            
            try:
                # Check for 'Id' field first (capital I, lowercase d)
                if 'Id' in candidate.feature.fields().names():
                    feature_id = candidate.feature['Id']
                    feedback.pushInfo(f"Using 'Id' field value: {feature_id}")
                # Only fall back to these if 'Id' is not found
                elif 'ID' in candidate.feature.fields().names():
                    feature_id = candidate.feature['ID']
                    feedback.pushInfo(f"Using 'ID' field value: {feature_id}")
                elif 'id' in candidate.feature.fields().names():
                    feature_id = candidate.feature['id']
                    feedback.pushInfo(f"Using 'id' field value: {feature_id}")
            except KeyError:
                feedback.pushInfo(f"No Id field found, using internal ID: {feature_id}")
            
            # Get proper Name for the feature
            feature_name = None
            try:
                # First check for 'Name' with capital N
                if 'Name' in candidate.feature.fields().names():
                    feature_name = str(candidate.feature['Name'])
                    feedback.pushInfo(f"Using 'Name' field value: {feature_name}")
                # Then check for lowercase 'name'
                elif 'name' in candidate.feature.fields().names():
                    feature_name = str(candidate.feature['name'])
                    feedback.pushInfo(f"Using 'name' field value: {feature_name}")
            except KeyError:
                pass
                
            # If no name was found, use Id as the name
            if not feature_name:
                feature_name = f'Candidate {feature_id}'
                feedback.pushInfo(f"No Name field found, using ID as name: {feature_name}")
            
            attrs = [feature_id, feature_name]

            # Add infrastructure attributes
            for layer in infra_layers:
                name = layer.name()
                info = candidate.infrastructures.get(name, {})
                
                # Get outage cost total for this infrastructure type
                outage_costs = candidate.outage_costs.get(name, [])
                outage_cost_total = sum(outage_costs)
                
                attrs.extend([
                    info.get('count', 0),
                    info.get('raw_score', 0),
                    info.get('normalized_score', 0),  # Changed from 'weighted_score' to match field name
                    outage_cost_total  
                ])
            
            # Add total scores
            attrs.append(candidate.total_infra_score)
            attrs.append(candidate.total_outage_cost_savings)
            
            # Add census attributes
            for var in census_variables:
                attrs.extend([
                    candidate.census_data.get(var, 0),
                    candidate.census_scores.get(var, 0)
                ])

            # Add zone scores
            for layer in zone_layers:
                name = layer.name()
                attrs.append(candidate.critical_zones.get(name, 0))

            # Add final scores
            attrs.extend([
                candidate.total_zone_score,
                candidate.final_score
            ])

            # Debug attribute count vs field count
            if len(attrs) != len(buffer_fields):
                feedback.pushWarning(f"Attribute count ({len(attrs)}) doesn't match field count ({len(buffer_fields)})")
                feedback.pushInfo(f"Fields: {[field.name() for field in buffer_fields]}")
                feedback.pushInfo(f"First 10 attributes: {attrs[:10]}")
                continue
                
            feature.setAttributes(attrs)
            
            # Check if feature is valid before adding
            if not feature.isValid():
                feedback.pushWarning(f"Invalid feature created for candidate {candidate.id}")
                continue
                
            result = sink.addFeature(feature, QgsFeatureSink.FastInsert)
            feedback.pushInfo(f"Added feature for candidate {candidate.id}: {'Success' if result else 'Failed'}")

            feedback.setProgress(80 + int((candidates.index(candidate) / len(candidates)) * 20))

        return {self.OUTPUT: dest_id}

    def get_intersecting_features(self, buffer, layer):
        """
        Get features from layer that intersect with buffer geometry.
        
        Args:
            buffer: Buffer geometry in the candidate's CRS
            layer: Layer to get features from, potentially in a different CRS
            
        Returns:
            List of features that intersect with buffer
        """
        intersecting_features = []
        
        # Check if the buffer geometry is valid
        if not buffer.isGeosValid():
            self.feedback.reportError(f"Buffer geometry is not valid for layer: {layer.name()}")
            return intersecting_features
        
        # Debug buffer information
        self.feedback.pushInfo(f"Buffer type: {buffer.wkbType()}, area: {buffer.area():.2f} sq meters")
        
        # Get buffer CRS information
        buffer_crs = QgsProject.instance().crs()
        layer_crs = layer.crs()
        
        self.feedback.pushInfo(f"Buffer CRS: {buffer_crs.authid()}, Layer CRS: {layer_crs.authid()}")
        
        # Get the buffer centroid for debugging
        centroid = buffer.centroid().asPoint()
        self.feedback.pushInfo(f"Buffer centroid: ({centroid.x():.6f}, {centroid.y():.6f})")
        
        # Calculate approximate buffer radius from area (for debugging)
        buffer_radius = (buffer.area() / 3.14159) ** 0.5
        self.feedback.pushInfo(f"Calculated buffer radius: {buffer_radius:.2f} meters")
        
        # Create a copy of the buffer geometry for transformation
        buffer_geom = QgsGeometry(buffer)
        
        # Transform buffer to layer CRS if needed
        if buffer_crs.authid() != layer_crs.authid():
            self.feedback.pushInfo(f"Transforming buffer from {buffer_crs.authid()} to {layer_crs.authid()}")
            try:
                transform = QgsCoordinateTransform(buffer_crs, layer_crs, QgsProject.instance())
                buffer_geom.transform(transform)
                
                # Debug the transformed buffer
                transformed_centroid = buffer_geom.centroid().asPoint()
                self.feedback.pushInfo(f"Transformed buffer centroid: ({transformed_centroid.x():.6f}, {transformed_centroid.y():.6f})")
                self.feedback.pushInfo(f"Transformed buffer area: {buffer_geom.area():.2f} sq meters")
            except Exception as e:
                self.feedback.reportError(f"Error transforming buffer: {str(e)}")
                # In case of transformation error, return empty result
                return intersecting_features
        
        # Get the correct bounding box from the buffer geometry
        bbox = buffer_geom.boundingBox()
        
        # Debug the bounding box (should be in the layer's CRS)
        self.feedback.pushInfo(f"Bounding box min: ({bbox.xMinimum():.6f}, {bbox.yMinimum():.6f})")
        self.feedback.pushInfo(f"Bounding box max: ({bbox.xMaximum():.6f}, {bbox.yMaximum():.6f})")
        self.feedback.pushInfo(f"Bounding box width: {bbox.width():.6f}, height: {bbox.height():.6f}")
        
        # ALWAYS create a manual bounding box for more reliable results
        # This fixes the issue with invalid bounding boxes
        center = buffer_geom.centroid().asPoint()
        
        # Set appropriate delta based on the CRS
        if layer_crs.authid().startswith("EPSG:4326"):
            # For EPSG:4326 (WGS 84), use degrees (about 2km at equator)
            delta = 0.02
        else:
            # For projected CRSs, use meters/feet based on buffer radius
            delta = buffer_radius * 1.1  # 10% larger than buffer radius
        
        # Create a manual bounding box
        manual_bbox = QgsRectangle(
            center.x() - delta,
            center.y() - delta,
            center.x() + delta,
            center.y() + delta
        )
        
        self.feedback.pushInfo(f"Created manual bbox: ({manual_bbox.xMinimum():.6f}, {manual_bbox.yMinimum():.6f}) - ({manual_bbox.xMaximum():.6f}, {manual_bbox.yMaximum():.6f})")
        bbox = manual_bbox
        
        # Use the corrected bounding box for spatial filtering
        request = QgsFeatureRequest().setFilterRect(bbox)
        
        # Count features in layer and in bounding box
        total_features = layer.featureCount()
        feature_count_in_bbox = 0
        contained_features = 0
        
        # Process features within the bounding box and check actual containment
        for feature in layer.getFeatures(request):
            feature_count_in_bbox += 1
            geom = feature.geometry()
            
            if not geom or not geom.isGeosValid():
                self.feedback.pushInfo(f"Skipping invalid geometry in layer {layer.name()}")
                continue
                
            # Check if the feature is truly inside or intersects the buffer
            # For point features, check containment
            if buffer_geom.contains(geom):
                contained_features += 1
                intersecting_features.append(feature)
                
                # Log only a limited number of points to avoid overwhelming logs
                if contained_features <= 5:
                    if geom.type() == QgsWkbTypes.PointGeometry:
                        point = geom.asPoint()
                        self.feedback.pushInfo(f"Found point inside buffer at {point.x():.6f}, {point.y():.6f}")
            elif buffer_geom.intersects(geom):
                # For non-point features that intersect but aren't contained
                intersecting_features.append(feature)
                contained_features += 1
                if contained_features <= 5:
                    self.feedback.pushInfo("Found intersecting feature (not contained)")
        
        # Report statistics
        self.feedback.pushInfo(f"Layer {layer.name()} has {total_features} total features")
        self.feedback.pushInfo(f"Features in bounding box: {feature_count_in_bbox}")
        self.feedback.pushInfo(f"Features actually contained or intersecting buffer: {contained_features}")
        
        # Add containment ratio statistics if applicable
        if feature_count_in_bbox > 0:
            containment_ratio = contained_features / feature_count_in_bbox
            self.feedback.pushInfo(f"Containment ratio: {containment_ratio:.2%}")
            
        return intersecting_features

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'EvaluateEnergyStorageSites'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Energy Storage Evaluation'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return EnergyStorageLocationEvaluatorAlgorithm()
