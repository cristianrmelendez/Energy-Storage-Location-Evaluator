# -*- coding: utf-8 -*-

"""
/***************************************************************************
 EnergyStorageLocationEvaluator
                                 A QGIS plugin
 A tool to evaluate potential locations for energy storage facilities, providing options for static and mobile configurations based on various spatial criteria.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-04-01
        copyright            : (C) 2024 by Cristian Melendez
        email                : cristian.melendez@upr.edu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Cristian Melendez'
__date__ = '2024-04-01'
__copyright__ = '(C) 2024 by Cristian Melendez'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import (QCoreApplication, QVariant)

from qgis.core import (QgsProcessing,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterDistance,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterMultipleLayers,
                       QgsProcessingParameterString,
                       QgsProcessingParameterEnum,
                       QgsFeatureRequest,
                       QgsFeature,
                       QgsFields,
                       QgsField,
                       QgsWkbTypes,
                       QgsFeatureSink,
                       QgsProcessingException,
                       )

from .candidate import Candidate
from .road_network_analyzer import RoadNetworkAnalyzer


class EnergyStorageLocationEvaluatorAlgorithm(QgsProcessingAlgorithm):

    # Inputs
    EVALUATION_TYPE = 'EVALUATION_TYPE'
    DISTANCE_METHOD = 'DISTANCE_METHOD'
    CANDIDATES_LAYER = 'CANDIDATES_LAYER'
    BUFFER_DISTANCE = 'BUFFER_DISTANCE'
    CRITICAL_INFRASTRUCTURES = 'CRITICAL_INFRASTRUCTURES'
    CENSUS_DATA_LAYER = 'CENSUS_DATA_LAYER'
    CENSUS_DATA_WEIGHTS = 'CENSUS_DATA_WEIGHTS'
    CRITICAL_ZONES = 'CRITICAL_ZONES'
    CRITICAL_ZONE_SCORES = 'CRITICAL_ZONE_SCORES'

    # Outputs
    OUTPUT = 'OUTPUT'  # Add this line

    def initAlgorithm(self, config=None):

        self.addParameter(
            QgsProcessingParameterEnum(
                self.EVALUATION_TYPE,
                self.tr('Select Evaluation Type'),
                options=['Static Energy Storage', 'Mobile Energy Storage'],
                defaultValue=0  # Default to Static Energy Storage
            )
        )

        self.addParameter(
            QgsProcessingParameterEnum(
                self.DISTANCE_METHOD,
                self.tr('Select distance calculation method '
                        '(Only for static case, for mobile the only option is time travel through the road network'),
                options=['Haversine distance (straight-line)', 'Road distance'],
                defaultValue=0  # Default to Haversine distance
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.CANDIDATES_LAYER,
                self.tr('Candidates Layer'),
                [QgsProcessing.TypeVectorPoint]
            )
        )

        self.addParameter(
            QgsProcessingParameterDistance(
                self.BUFFER_DISTANCE,
                self.tr('Buffer distance in km'),
                parentParameterName=self.CANDIDATES_LAYER,
                defaultValue=1.0,
                minValue=0
            )
        )

        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                self.CRITICAL_INFRASTRUCTURES,
                self.tr('Critical Infrastructure Layers'),
                QgsProcessing.TypeVectorPoint
            )
        )

        # Add a string parameter for users to input weights separated by a comma, space, or another delimiter
        self.addParameter(
            QgsProcessingParameterString(
                'INFRASTRUCTURE_WEIGHTS',
                self.tr('Enter the weights for each infrastructure layer (comma-separated)'
                        ' in the same order as the layers. It must sum to 1.0.'),
                defaultValue='0.25,0.25,0.25,0.25'  # Example default value for 4 layers
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.CENSUS_DATA_LAYER,
                self.tr('Input here you Census Data Layer'),
                [QgsProcessing.TypeVectorPolygon]  # Accept only polygon layers
            )
        )

        self.addParameter(
            QgsProcessingParameterString(
                self.CENSUS_DATA_WEIGHTS,
                self.tr('Enter weights for the census data variables (comma-separated)'),
                defaultValue='0.25,0.25,0.25,0.25'  # Example default value for 4 layers
            )
        )

        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                self.CRITICAL_ZONES,
                self.tr('Critical Zones Layers'),
                QgsProcessing.TypeVectorPolygon  # Only polygon layers
            )
        )

        self.addParameter(
            QgsProcessingParameterString(
                self.CRITICAL_ZONE_SCORES,
                self.tr('Enter the scores for each critical zone layer (comma-separated)'
                        ' in the same order as the layers. Use negative values to subtract score.'),
                defaultValue='10,-5,-10'  # Example default value
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,  # This is the key line to define the OUTPUT parameter
                self.tr('Output layer')
            )
        )

    def safe_field_name(self, layer_name):
        # Replace spaces with underscores and remove special characters
        return ''.join([c if c.isalnum() or c == '_' else '' for c in layer_name.replace(' ', '_')])

    def processAlgorithm(self, parameters, context, feedback):
        print("Starting processAlgorithm")
        candidate_layer = self.parameterAsSource(parameters, self.CANDIDATES_LAYER, context)
        buffer_distance = self.parameterAsDouble(parameters, self.BUFFER_DISTANCE, context)
        energy_storage_type = self.parameterAsEnum(parameters, self.EVALUATION_TYPE, context)
        distance_method = self.parameterAsEnum(parameters, self.DISTANCE_METHOD, context)

        infra_layers = self.parameterAsLayerList(parameters, self.CRITICAL_INFRASTRUCTURES, context)
        infra_weights_str = self.parameterAsString(parameters, 'INFRASTRUCTURE_WEIGHTS', context)
        infra_weights = [float(w) for w in infra_weights_str.split(',')]

        if len(infra_weights) != len(infra_layers):
            raise QgsProcessingException(
                "The number of weights does not match the number of critical infrastructure layers.")

        print(f"Energy Storage Type: {energy_storage_type}, Distance Method: {distance_method}")

        road_analyzer = RoadNetworkAnalyzer()
        candidates = []

        for feature in candidate_layer.getFeatures():
            candidate = Candidate(feature, buffer_distance)
            candidates.append(candidate)

        for i, infra_layer in enumerate(infra_layers):
            infra_name = self.safe_field_name(infra_layer.name())
            weight = infra_weights[i]
            print(f"Processing infrastructure: {infra_name} with weight {weight}")
            for candidate in candidates:
                intersecting_features = self.get_intersecting_features(candidate.buffer, infra_layer)
                for infra_feature in intersecting_features:
                    if energy_storage_type == 0:  # Static
                        if distance_method == 0:  # Haversine
                            distance = candidate.feature.geometry().distance(infra_feature.geometry())
                            print(f"Haversine Distance: {distance}")
                        else:  # Road distance
                            start_point = candidate.feature.geometry().asPoint()
                            end_point = infra_feature.geometry().asPoint()
                            distance = road_analyzer.calculate_road_distance(start_point.x(), start_point.y(),
                                                                             end_point.x(), end_point.y())
                            print(f"Road Distance: {distance}")
                    else:  # Mobile, using ETA
                        start_point = candidate.feature.geometry().asPoint()
                        end_point = infra_feature.geometry().asPoint()
                        distance = road_analyzer.calculate_eta(start_point.x(), start_point.y(), end_point.x(),
                                                               end_point.y())
                        print(f"ETA: {distance}")

                    score = (buffer_distance - distance) * weight
                    print(f"Calculated Score: {score}")
                    candidate.add_infrastructure_score(infra_name, 1, score)

        for candidate in candidates:
            candidate.calculate_final_score()
            print(f"Candidate Final Score: {candidate.final_score}")

        #################### Generate the output Layer
        buffer_fields = QgsFields()
        buffer_fields.append(QgsField('id', QVariant.Int))
        buffer_fields.append(QgsField('name', QVariant.String))
        # Add fields for each infrastructure type's count and score

        for infra_layer in infra_layers:
            infra_name = self.safe_field_name(infra_layer.name())
            buffer_fields.append(QgsField(f'{infra_name}_Count', QVariant.Int))
            buffer_fields.append(QgsField(f'{infra_name}_Score', QVariant.Double))

        # Add fields for census data and critical zones if you are processing them similarly
        # buffer_fields.append(QgsField('Census_Data_Score', QVariant.Double))
        # buffer_fields.append(QgsField('Critical_Zone_Score', QVariant.Double))

        # Finally, add a field for the final score
        buffer_fields.append(QgsField('Final_Score', QVariant.Double))

        # Create the output layer
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT, context, buffer_fields, QgsWkbTypes.Polygon,
                                               candidate_layer.sourceCrs())

        # Populate the output layer with features
        for candidate in candidates:
            # Create a new feature for the output layer
            out_feature = QgsFeature(buffer_fields)
            out_feature.setGeometry(candidate.buffer)  # Set the buffer geometry as the feature's geometry

            # Prepare the attributes list starting with ID and name
            attributes = [candidate.feature['id'], candidate.feature['name']]

            # Append the counts and scores for each infrastructure type
            for infra_layer in infra_layers:
                infra_name = self.safe_field_name(infra_layer.name())
                count = candidate.infrastructures.get(infra_name, {}).get('count', 0)
                score = candidate.infrastructures.get(infra_name, {}).get('score', 0)
                attributes += [count, score]

            # Append census data and critical zones scores if applicable
            # attributes.append(candidate.census_data_score)
            # attributes.append(candidate.critical_zone_score)

            # Append the final score
            attributes.append(candidate.final_score)

            # Assign the attributes to the output feature and add it to the sink
            out_feature.setAttributes(attributes)
            sink.addFeature(out_feature, QgsFeatureSink.FastInsert)

        # Return the results including the output layer
        return {self.OUTPUT: dest_id}

    def get_intersecting_features(self, buffer, layer):
        print("Getting intersecting features")
        intersecting_features = []
        # Commenting out the bounding box filter for debugging
        # request = QgsFeatureRequest().setFilterRect(buffer.boundingBox())
        for feature in layer.getFeatures():  # Removed the request object
            geom = feature.geometry()
            if geom is not None:  # Check if geometry is valid
                print(f"Checking feature {feature.id()} with geometry {geom.asWkt()}")
                if geom.intersects(buffer):
                    print(f"Feature {feature.id()} intersects with the buffer.")
                    intersecting_features.append(feature)
                else:
                    print(f"Feature {feature.id()} does not intersect with the buffer.")
            else:
                print(f"Feature {feature.id()} has invalid geometry.")
        return intersecting_features

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'EvaluateEnergyStorageSites'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Energy Storage Evaluation'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return EnergyStorageLocationEvaluatorAlgorithm()
